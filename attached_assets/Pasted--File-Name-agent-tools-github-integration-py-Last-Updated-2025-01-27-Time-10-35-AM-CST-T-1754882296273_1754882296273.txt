# File Name: agent/tools/github_integration.py

# Last Updated: 2025-01-27 | Time: 10:35 AM CST

# Total Lines: 480

# Version: 1.0

“””
GitHub Integration Tool - Manages GitHub issues, PRs, and repository operations
Enables autonomous issue resolution and code contribution
“””

import os
import json
import logging
import tempfile
import shutil
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
from datetime import datetime
import git
from github import Github, GithubException
import base64
import requests

logger = logging.getLogger(**name**)

class GitHubIntegrationTool:
“””
GitHub integration for autonomous issue resolution and PR creation
“””

```
def __init__(self, token: str = None):
    """
    Initialize GitHub integration
    
    Args:
        token: GitHub personal access token
    """
    self.token = token or os.getenv('GITHUB_TOKEN')
    self.github = Github(self.token) if self.token else None
    self.workspace = Path('./github_workspace')
    self.workspace.mkdir(exist_ok=True)
    
    logger.info("GitHub Integration initialized")

def fetch_repository_issues(self, 
                            repo_name: str,
                            state: str = 'open',
                            labels: List[str] = None) -> List[Dict[str, Any]]:
    """
    Fetch issues from a GitHub repository
    
    Args:
        repo_name: Repository name (owner/repo)
        state: Issue state (open, closed, all)
        labels: Filter by labels
        
    Returns:
        List of issues with details
    """
    try:
        repo = self.github.get_repo(repo_name)
        
        # Build query parameters
        kwargs = {'state': state}
        if labels:
            kwargs['labels'] = [repo.get_label(label) for label in labels]
        
        issues = repo.get_issues(**kwargs)
        
        issue_list = []
        for issue in issues[:50]:  # Limit to 50 issues
            issue_data = {
                'number': issue.number,
                'title': issue.title,
                'body': issue.body,
                'state': issue.state,
                'labels': [label.name for label in issue.labels],
                'created_at': issue.created_at.isoformat(),
                'updated_at': issue.updated_at.isoformat(),
                'comments': issue.comments,
                'assignees': [a.login for a in issue.assignees],
                'is_pull_request': issue.pull_request is not None
            }
            
            # Skip PRs if we're looking for issues
            if not issue_data['is_pull_request']:
                issue_list.append(issue_data)
        
        return issue_list
        
    except Exception as e:
        logger.error(f"Failed to fetch issues: {e}")
        return []

def analyze_issue(self, repo_name: str, issue_number: int) -> Dict[str, Any]:
    """
    Analyze a specific issue in detail
    
    Args:
        repo_name: Repository name (owner/repo)
        issue_number: Issue number
        
    Returns:
        Detailed issue analysis
    """
    try:
        repo = self.github.get_repo(repo_name)
        issue = repo.get_issue(issue_number)
        
        # Fetch issue comments
        comments = []
        for comment in issue.get_comments():
            comments.append({
                'author': comment.user.login,
                'body': comment.body,
                'created_at': comment.created_at.isoformat()
            })
        
        # Analyze issue type
        issue_type = self._classify_issue(issue.title, issue.body, issue.labels)
        
        # Extract code snippets
        code_snippets = self._extract_code_snippets(issue.body)
        
        # Extract error messages
        error_messages = self._extract_error_messages(issue.body)
        
        # Find related files
        related_files = self._find_related_files(issue.body, comments)
        
        return {
            'number': issue.number,
            'title': issue.title,
            'body': issue.body,
            'type': issue_type,
            'priority': self._determine_priority(issue.labels),
            'complexity': self._estimate_complexity(issue.body, code_snippets),
            'labels': [label.name for label in issue.labels],
            'comments': comments,
            'code_snippets': code_snippets,
            'error_messages': error_messages,
            'related_files': related_files,
            'created_at': issue.created_at.isoformat(),
            'updated_at': issue.updated_at.isoformat()
        }
        
    except Exception as e:
        logger.error(f"Failed to analyze issue: {e}")
        raise

def clone_repository(self, repo_name: str, branch: str = 'main') -> Path:
    """
    Clone a GitHub repository
    
    Args:
        repo_name: Repository name (owner/repo)
        branch: Branch to clone
        
    Returns:
        Path to cloned repository
    """
    try:
        repo_path = self.workspace / repo_name.replace('/', '_')
        
        if repo_path.exists():
            # Pull latest changes
            repo = git.Repo(repo_path)
            origin = repo.remotes.origin
            origin.pull(branch)
            logger.info(f"Updated existing repository: {repo_name}")
        else:
            # Clone new repository
            clone_url = f"https://github.com/{repo_name}.git"
            if self.token:
                # Use token for private repos
                clone_url = f"https://{self.token}@github.com/{repo_name}.git"
            
            repo = git.Repo.clone_from(clone_url, repo_path, branch=branch)
            logger.info(f"Cloned repository: {repo_name}")
        
        return repo_path
        
    except Exception as e:
        logger.error(f"Failed to clone repository: {e}")
        raise

def create_branch(self, repo_path: Path, branch_name: str) -> bool:
    """
    Create a new branch in the repository
    
    Args:
        repo_path: Path to repository
        branch_name: Name for new branch
        
    Returns:
        Success status
    """
    try:
        repo = git.Repo(repo_path)
        
        # Create and checkout new branch
        new_branch = repo.create_head(branch_name)
        new_branch.checkout()
        
        logger.info(f"Created branch: {branch_name}")
        return True
        
    except Exception as e:
        logger.error(f"Failed to create branch: {e}")
        return False

def commit_changes(self, 
                  repo_path: Path,
                  files: List[str],
                  message: str) -> bool:
    """
    Commit changes to the repository
    
    Args:
        repo_path: Path to repository
        files: List of files to commit
        message: Commit message
        
    Returns:
        Success status
    """
    try:
        repo = git.Repo(repo_path)
        
        # Add files
        for file in files:
            repo.index.add([file])
        
        # Commit
        repo.index.commit(message)
        
        logger.info(f"Committed changes: {message}")
        return True
        
    except Exception as e:
        logger.error(f"Failed to commit changes: {e}")
        return False

def create_pull_request(self,
                       repo_name: str,
                       title: str,
                       body: str,
                       head_branch: str,
                       base_branch: str = 'main',
                       issue_number: int = None) -> Dict[str, Any]:
    """
    Create a pull request
    
    Args:
        repo_name: Repository name (owner/repo)
        title: PR title
        body: PR description
        head_branch: Source branch
        base_branch: Target branch
        issue_number: Related issue number
        
    Returns:
        Pull request details
    """
    try:
        repo = self.github.get_repo(repo_name)
        
        # Add issue reference to body if provided
        if issue_number:
            body = f"Fixes #{issue_number}\n\n{body}"
        
        # Create PR
        pr = repo.create_pull(
            title=title,
            body=body,
            head=head_branch,
            base=base_branch
        )
        
        # Add labels if issue number provided
        if issue_number:
            try:
                issue = repo.get_issue(issue_number)
                pr.add_to_labels(*issue.labels)
            except:
                pass
        
        return {
            'number': pr.number,
            'url': pr.html_url,
            'title': pr.title,
            'state': pr.state,
            'created_at': pr.created_at.isoformat()
        }
        
    except Exception as e:
        logger.error(f"Failed to create pull request: {e}")
        raise

def push_branch(self, repo_path: Path, branch_name: str) -> bool:
    """
    Push branch to remote repository
    
    Args:
        repo_path: Path to repository
        branch_name: Branch to push
        
    Returns:
        Success status
    """
    try:
        repo = git.Repo(repo_path)
        origin = repo.remotes.origin
        
        # Set upstream and push
        repo.git.push('--set-upstream', 'origin', branch_name)
        
        logger.info(f"Pushed branch: {branch_name}")
        return True
        
    except Exception as e:
        logger.error(f"Failed to push branch: {e}")
        return False

def get_file_content(self, repo_name: str, file_path: str, ref: str = 'main') -> str:
    """
    Get content of a file from GitHub
    
    Args:
        repo_name: Repository name (owner/repo)
        file_path: Path to file in repository
        ref: Branch, tag, or commit SHA
        
    Returns:
        File content
    """
    try:
        repo = self.github.get_repo(repo_name)
        file_content = repo.get_contents(file_path, ref=ref)
        
        if file_content.encoding == 'base64':
            return base64.b64decode(file_content.content).decode('utf-8')
        else:
            return file_content.content
            
    except Exception as e:
        logger.error(f"Failed to get file content: {e}")
        return ""

def search_code(self, 
               query: str,
               repo_name: str = None,
               language: str = None) -> List[Dict[str, Any]]:
    """
    Search code on GitHub
    
    Args:
        query: Search query
        repo_name: Limit to specific repository
        language: Filter by language
        
    Returns:
        Search results
    """
    try:
        # Build search query
        search_query = query
        if repo_name:
            search_query += f" repo:{repo_name}"
        if language:
            search_query += f" language:{language}"
        
        # Search code
        results = self.github.search_code(search_query)
        
        search_results = []
        for result in results[:20]:  # Limit to 20 results
            search_results.append({
                'name': result.name,
                'path': result.path,
                'repository': result.repository.full_name,
                'url': result.html_url,
                'score': result.score
            })
        
        return search_results
        
    except Exception as e:
        logger.error(f"Failed to search code: {e}")
        return []

def add_issue_comment(self, 
                     repo_name: str,
                     issue_number: int,
                     comment: str) -> bool:
    """
    Add a comment to an issue
    
    Args:
        repo_name: Repository name (owner/repo)
        issue_number: Issue number
        comment: Comment text
        
    Returns:
        Success status
    """
    try:
        repo = self.github.get_repo(repo_name)
        issue = repo.get_issue(issue_number)
        issue.create_comment(comment)
        
        logger.info(f"Added comment to issue #{issue_number}")
        return True
        
    except Exception as e:
        logger.error(f"Failed to add comment: {e}")
        return False

def get_repository_structure(self, repo_name: str) -> Dict[str, Any]:
    """
    Get repository structure and metadata
    
    Args:
        repo_name: Repository name (owner/repo)
        
    Returns:
        Repository structure
    """
    try:
        repo = self.github.get_repo(repo_name)
        
        # Get repository tree
        contents = repo.get_contents("")
        
        structure = {
            'name': repo.name,
            'description': repo.description,
            'language': repo.language,
            'languages': repo.get_languages(),
            'topics': repo.get_topics(),
            'default_branch': repo.default_branch,
            'files': self._build_file_tree(repo, contents)
        }
        
        return structure
        
    except Exception as e:
        logger.error(f"Failed to get repository structure: {e}")
        return {}

def _build_file_tree(self, repo, contents, path: str = "") -> List[Dict[str, Any]]:
    """Build file tree recursively"""
    tree = []
    
    for content in contents:
        if content.type == "dir":
            # Recursively get directory contents
            sub_contents = repo.get_contents(content.path)
            tree.append({
                'name': content.name,
                'type': 'directory',
                'path': content.path,
                'children': self._build_file_tree(repo, sub_contents, content.path)
            })
        else:
            tree.append({
                'name': content.name,
                'type': 'file',
                'path': content.path,
                'size': content.size
            })
    
    return tree

def _classify_issue(self, title: str, body: str, labels: List) -> str:
    """Classify issue type based on content"""
    title_lower = title.lower()
    body_lower = (body or "").lower()
    label_names = [label.name.lower() for label in labels]
    
    # Check for bug indicators
    bug_keywords = ['bug', 'error', 'crash', 'fail', 'broken', 'issue', 'problem']
    if any(keyword in title_lower or keyword in body_lower or keyword in label_names 
           for keyword in bug_keywords):
        return 'bug'
```